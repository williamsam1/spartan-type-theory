Load "examples/lemmas.tt".

Definition fmap := (fun (A : Type) (B : A -> Type)
    (f : Π (x : A), B x) (a : Comp A) => Fmap f a)
    : Π (A : Type) (B : A -> Type),
        (Π (x : A), B x) -> Π (a : Comp A), Comp (B (CompEval a)).
Definition liftA := (fun (A : Type) (B : A -> Type)
    (f : Comp (Π (x : A), B x)) (a : Comp A) => LiftA f a)
    : Π (A : Type) (B : A -> Type),
        Comp (Π (x : A), B x) -> Π (a : Comp A), Comp (B (CompEval a)).
Definition ret := (fun (A : Type) (a : A) => Ret a)
	: Π (A : Type), A -> Comp A.
Definition eval := (fun (A : Type) (a : Comp A) => CompEval a)
	: Π (A : Type), Comp A -> A.

(** Time to evaluate successor function application *)
Definition S_time := (fun (n : Nat) => CompEval (Time (Fmap S (Ret n))))
    : Nat -> Nat.
(** f 0 == 1 *)
Definition S_time_0 := (Refl (S Z))
    : Eq (S_time Z) (S Z).
(** f (S n) == 1 *)
Definition S_time_S := (fun (n : Nat) => (Refl (S Z)))
    : Π (n : Nat), Eq (S_time (S n)) (S Z).
(** f n == 1 *)
Definition S_time_eq := (fun (n : Nat) =>
    nat_ind (fun (n : Nat) => Eq (S_time n) (S Z))
    S_time_0
    (fun (n : Nat) (_ : Eq (S_time n) (S Z)) => S_time_S n)
    n)
    : Π (n : Nat), Eq (S_time n) (S Z).

(** Time to evaluate recursively defined addition *)
Definition plusTime := (fun (m n : Nat) => CompEval (Time (LiftA (Fmap ( + ) (Ret m)) (Ret n))))
    : Nat -> Nat -> Nat.

(** f 0 n == 2 *)
Definition plusTime0 := (fun (n : Nat) => Refl (S (S Z)))
    : Π (n : Nat), Eq (plusTime Z n) (S (S Z)).

(** f (S m) n == S (f m n) *)
Definition plusTimeS := (fun (m n : Nat) => Refl (plusTime (S m) n))
    : Π (m n : Nat), Eq (plusTime (S m) n) (S (plusTime m n)).

(** g m = m + 2 *)
Definition plusTimeSimpl := (fun (n : Nat) => n + two)
    : Nat -> Nat.

(** g m = f m 0 *)
Definition plusTimeSimplEq :=
    (nat_ind (fun (n : Nat) => Eq (plusTimeSimpl n) (plusTime n Z))
        (plusTime0 Z)
        (fun (n : Nat) (p : Eq (plusTimeSimpl n) (plusTime n Z)) =>
            trans Nat (plusTimeSimpl (S n)) (S (plusTime n Z)) (plusTime (S n) Z)
                (ap Nat Nat S (plusTimeSimpl n) (plusTime n Z) p)
                (sym Nat (plusTime (S n) Z) (S (plusTime n Z)) (plusTimeS n Z))
        )
    )
    : Π (n : Nat), Eq (plusTimeSimpl n) (plusTime n Z).

(** f m n1 == f m n2 *)
Definition plusTimeSecondEq :=
    (nat_ind (fun (m : Nat) => Π (n1 n2 : Nat), Eq (plusTime m n1) (plusTime m n2))
        (fun (n1 n2 : Nat) => trans Nat (plusTime Z n1) (S (S Z)) (plusTime Z n2) (plusTime0 n1) (sym Nat (plusTime Z n2) (S (S Z)) (plusTime0 n2)))
        (fun (m : Nat) (p : Π (n1 n2 : Nat), Eq (plusTime m n1) (plusTime m n2)) (n1 n2 : Nat) => 
            trans2 Nat (plusTime (S m) n1) (S (plusTime m n1)) (S (plusTime m n2)) (plusTime (S m) n2)
                (plusTimeS m n1)
                (ap Nat Nat S (plusTime m n1) (plusTime m n2) (p n1 n2))
                (sym Nat (plusTime (S m) n2) (S (plusTime m n2)) (plusTimeS m n2)))
    )
    : Π (m n1 n2 : Nat), Eq (plusTime m n1) (plusTime m n2).

(** f m n == m + 2 *)
Definition plusTimeEq := (irrelev Nat Nat Nat plusTime plusTimeSimpl Z plusTimeSecondEq plusTimeSimplEq)
    : Π (m n : Nat), Eq (plusTimeSimpl m) (plusTime m n).

Definition multiplyTime := (fun (m n : Nat) => CompEval (Time (LiftA (Fmap ( * ) (Ret m)) (Ret n)))) 
	: Nat -> Nat -> Nat.

Definition Bool := (Π (A : Type), A -> A -> A) : Type.
Definition true := (fun (A: Type) (x y : A) => x) : Bool.
Definition false := (fun (A: Type) (x y : A) => y) : Bool.
Definition isZero := (nat_rec Bool true (fun (_ : Bool ) => false)) : Nat -> Bool.
Definition pred := nat_rec2 Nat Z (fun (y : Nat) (_ : Nat) => (nat_rec2 Nat Z (fun (n : Nat) (_ : Nat) => S n) y)). 
Definition multiplyTimeExplicit := (fun (m n : Nat) => isZero m Nat two (two * (pred m) + n + six)) 
	: Nat -> Nat -> Nat. 

Eval (multiplyTime one Z).
Axiom m : Nat.
Axiom n : Nat. 
Eval (multiplyTime one (S m)).
Eval (multiplyTime (S (S n)) (S m)).
Eval (CompEval (Time (Fmap ( * ) (Ret n)))).
Eval (CompEval (Time (Fmap ( * ) (Ret Z)))).
Eval (CompEval (Time (Fmap ( * ) (Ret ((S n)))))).

Eval (pred Z).
Eval (pred (S Z)).
Eval (pred two).
Eval (pred three).
Eval (multiplyTimeExplicit Z Z ).
Eval (multiplyTimeExplicit one Z ).
Eval (multiplyTimeExplicit one one ).
Eval (multiplyTimeExplicit two three ).

Eval (isZero Z).
Eval (isZero one).

Eval (multiplyTime Z Z).
Eval (multiplyTime one Z).
Eval (multiplyTime two Z).
Eval (multiplyTime three Z).
Eval (multiplyTime Z one).
Eval (multiplyTime one one).
Eval (multiplyTime one two).
Eval (multiplyTime three one).
Eval (multiplyTime one three).
Eval (multiplyTime two two).
