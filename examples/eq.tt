(** Propositional equality *)
Definition eq := (fun (A : Type) (x y : A) => Eq x y)
	: forall (A : Type), A -> A -> Type.
Definition refl := (fun (A : Type) (x : A) => Refl x)
	: forall (A : Type) (x : A), eq A x x.
Definition J := (fun (A : Type) (P : forall (x y : A), eq A x y -> Type)
	(r : forall (x : A), P x x (refl A x))
	(x y : A) (p : eq A x y) => EqInd P r x y p)
	: forall (A : Type) (P : forall (x y : A), eq A x y -> Type),
	(forall (x : A), P x x (refl A x))
	-> forall (x y : A) (p : eq A x y), P x y p.
Definition sym := (fun (A : Type) =>
	J A (fun (x y : A) (p : Eq x y) => Eq y x)
		(fun (x : A) => Refl x))
	: forall (A : Type) (x y : A), Eq x y -> Eq y x.
Definition trans := (fun (A : Type) (x y z : A) (p1 : Eq x y) (p2 : Eq y z) =>
	J A (fun (x y : A) (p : Eq x y) => forall (z : A), Eq y z -> Eq x z)
		(fun (x z : A) (p : Eq x z) => p)
		x y p1 z p2)
	: forall (A : Type) (x y z : A), Eq x y -> Eq y z -> Eq x z.

(** x == y -> f x == f y *)
Definition ap := (fun (A B : Type) (f : A -> B) =>
	J A (fun (x y : A) (p : Eq x y) => Eq (f x) (f y)) (fun (x : A) => Refl (f x)))
	: forall (A B : Type) (f : A -> B) (x y : A), Eq x y -> Eq (f x) (f y).

(** x == y -> P x -> P y *)
Definition tp := (fun (A : Type) (P : A -> Type) =>
	J A (fun (x y : A) (p : Eq x y) => P x -> P y) (fun (x : A) (p : P x) => p))
	: forall (A : Type) (P : A -> Type) (x y : A), Eq x y -> P x -> P y.

Definition suc := (fun (n : Nat) => Suc n)
	   : Nat -> Nat.

Definition ( + ) := (fun (m n : Nat) => Plus m n)
	   : Nat -> Nat -> Nat.

Definition natInd := (fun (P : Nat -> Type) (a : P Zero)
	   (f : forall (n : Nat), P n -> P (Suc n)) (n : Nat) => NatInd P a f n).

Definition one := suc Zero.
Definition two_v1 := one + one.
Definition two_v2 := suc one.
Definition two_v1_eq_two_v2 := Refl two_v1 : Eq two_v1 two_v2.

(** Propositional equality for definition of addition *)

(** Z + n == n *)
Definition plus_Z := (fun (n : Nat) => Refl n)
	: forall (n : Nat), Eq (Zero + n) n.

(** S m + n == S (m + n) *)
Definition plus_S := (fun (m n : Nat) => Refl (suc m + n))
	: forall (m n : Nat), Eq (suc m + n) (suc (m + n)).
Check plus_Z.
Check plus_S.

(** Commutativity of addition *)

(** n + Z == n *)
Definition n_plus_Z :=
	natInd (fun (n : Nat) => Eq (n + Zero) n)
	(Refl Zero)
	(fun (n : Nat) => ap Nat Nat suc (n + Zero) n)
	: forall (n : Nat), Eq (n + Zero) n.
